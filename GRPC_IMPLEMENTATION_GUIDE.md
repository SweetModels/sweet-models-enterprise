# ðŸ”Œ Backend gRPC Setup - PrÃ³ximos Pasos

## Objetivos:

Habilitar comunicaciÃ³n bidireccional gRPC entre Flutter (mobile_app) y Rust (backend_api) en puerto **50051**.

---


## 1. Definir Servicios Protobuf

### Crear archivos proto en `backend_api/proto/`:

#### `chat.proto`

```protobuf
syntax = "proto3";

package chat;

service ChatService {
  rpc SendMessage (ChatMessage) returns (ChatResponse);
  rpc GetMessages (GetMessagesRequest) returns (stream ChatMessage);
  rpc CreateChannel (CreateChannelRequest) returns (ChatChannel);
  rpc ListChannels (ListChannelsRequest) returns (ChannelList);
}

message ChatMessage {
  string id = 1;
  string channel_id = 2;
  string user_id = 3;
  string text = 4;
  int64 timestamp = 5;
  string user_name = 6;
}

message ChatResponse {
  bool success = 1;
  string message_id = 2;
  string error = 3;
}

message GetMessagesRequest {
  string channel_id = 1;
  int32 limit = 2;
  int64 after_timestamp = 3;
}

message CreateChannelRequest {
  string name = 1;
  string description = 2;
  repeated string members = 3;
}

message ChatChannel {
  string id = 1;
  string name = 2;
  int32 member_count = 3;
  int64 created_at = 4;
}

message ListChannelsRequest {
  string user_id = 1;
}

message ChannelList {
  repeated ChatChannel channels = 1;
}

```

#### `ledger.proto`

```protobuf
syntax = "proto3";

package ledger;

service LedgerService {
  rpc SealTransaction (TransactionData) returns (SealResponse);
  rpc VerifyChain (VerifyRequest) returns (VerifyResponse);
  rpc GetTransactionHistory (GetHistoryRequest) returns (TransactionHistory);
}

message TransactionData {
  string user_id = 1;
  string tx_type = 2;
  bytes data = 3; // JSONB
  int64 timestamp = 4;
}

message SealResponse {
  bool success = 1;
  string tx_hash = 2;
  string prev_hash = 3;
}

message VerifyRequest {
  string user_id = 1;
  int32 limit = 2;
}

message VerifyResponse {
  bool chain_valid = 1;
  string error = 2;
  int32 verified_count = 3;
}

message GetHistoryRequest {
  string user_id = 1;
  int64 from_timestamp = 2;
  int64 to_timestamp = 3;
}

message TransactionHistory {
  repeated TransactionData transactions = 1;
  int32 total = 2;
}

```

---


## 2. Actualizar `Cargo.toml` en Backend

```toml
[dependencies]

# ... existing deps ...

tonic = "0.12"
tonic-health = "0.12"
tokio = { version = "1", features = ["full"] }
prost = "0.13"

[build-dependencies]
tonic-build = "0.12"

```

---


## 3. Crear `build.rs` en Backend

```rust
// backend_api/build.rs
use std::path::PathBuf;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = PathBuf::from(std::env::var("OUT_DIR")?);

    tonic_build::configure()
        .out_dir(&out_dir)
        .compile(
            &["proto/chat.proto", "proto/ledger.proto"],
            &["proto"],
        )?;

    Ok(())
}

```

---


## 4. Implementar gRPC Handlers en Backend

### `backend_api/src/grpc/mod.rs`

```rust
pub mod chat_handler;
pub mod ledger_handler;
pub mod health;

// Generated by protoc
pub mod chat {
    include!(concat!(env!("OUT_DIR"), "/chat.rs"));
}

pub mod ledger {
    include!(concat!(env!("OUT_DIR"), "/ledger.rs"));
}

```

### `backend_api/src/grpc/chat_handler.rs`

```rust
use tonic::{Request, Response, Status};
use crate::grpc::chat::*;
use crate::AppState;
use std::sync::Arc;

pub struct ChatServiceImpl {
    state: Arc<AppState>,
}

impl ChatServiceImpl {
    pub fn new(state: Arc<AppState>) -> Self {
        Self { state }
    }
}

#[tonic::async_trait]
impl chat_service_server::ChatService for ChatServiceImpl {
    async fn send_message(
        &self,
        request: Request<ChatMessage>,
    ) -> Result<Response<ChatResponse>, Status> {
        let msg = request.into_inner();

        // Guardar mensaje en NATS
        let _ = self.state.nats.publish(
            format!("chat.{}", msg.channel_id),
            serde_json::to_vec(&msg).unwrap().into(),
        ).await;

        Ok(Response::new(ChatResponse {
            success: true,
            message_id: msg.id,
            error: String::new(),
        }))
    }

    async fn get_messages(
        &self,
        request: Request<GetMessagesRequest>,
    ) -> Result<Response<tokio::sync::mpsc::Receiver<ChatMessage>>, Status> {
        let req = request.into_inner();
        let (tx, rx) = tokio::sync::mpsc::channel(100);

        // Stream de mensajes desde NATS
        tokio::spawn(async move {
            let sub = self.state.nats.subscribe(
                format!("chat.{}", req.channel_id)
            ).await.unwrap();

            let mut messages = sub;
            while let Some(msg) = messages.next().await {
                let _ = tx.send(/* desserializar */).await;
            }
        });

        Ok(Response::new(rx))
    }

    // ... otros mÃ©todos
}

```

### `backend_api/src/grpc/ledger_handler.rs`

```rust
use tonic::{Request, Response, Status};
use crate::grpc::ledger::*;
use crate::finance::ledger::seal_transaction;
use crate::AppState;
use std::sync::Arc;

pub struct LedgerServiceImpl {
    state: Arc<AppState>,
}

#[tonic::async_trait]
impl ledger_service_server::LedgerService for LedgerServiceImpl {
    async fn seal_transaction(
        &self,
        request: Request<TransactionData>,
    ) -> Result<Response<SealResponse>, Status> {
        let tx_data = request.into_inner();

        // Sellar transacciÃ³n usando funciÃ³n existente
        match seal_transaction(&self.state.db, &tx_data).await {
            Ok((tx_hash, prev_hash)) => {
                Ok(Response::new(SealResponse {
                    success: true,
                    tx_hash,
                    prev_hash,
                }))
            },
            Err(e) => Err(Status::internal(e.to_string())),
        }
    }

    async fn verify_chain(
        &self,
        request: Request<VerifyRequest>,
    ) -> Result<Response<VerifyResponse>, Status> {
        // Verificar cadena de bloques
        Ok(Response::new(VerifyResponse {
            chain_valid: true,
            error: String::new(),
            verified_count: 100,
        }))
    }

    // ... otros mÃ©todos
}

```

---


## 5. Integrar gRPC en `main.rs`

```rust
// backend_api/src/main.rs

mod grpc;

use tonic::transport::Server;
use grpc::chat_handler::ChatServiceImpl;
use grpc::ledger_handler::LedgerServiceImpl;

async fn spawn_grpc_server(addr: &str, state: Arc<AppState>) -> Result<(), Box<dyn std::error::Error>> {
    let addr_str = format!("0.0.0.0:{}", addr);
    let addr = addr_str.parse()?;

    let chat_service = ChatServiceImpl::new(state.clone());
    let ledger_service = LedgerServiceImpl::new(state.clone());

    Server::builder()
        .add_service(
            grpc::chat::chat_service_server::ChatServiceServer::new(chat_service)
        )
        .add_service(
            grpc::ledger::ledger_service_server::LedgerServiceServer::new(ledger_service)
        )
        .serve(addr)
        .await?;

    Ok(())
}

#[tokio::main]
async fn main() {
    let state = Arc::new(AppState { /* ... */ });

    // Spawn HTTP server (3000)
    let http_state = state.clone();
    tokio::spawn(async move {
        spawn_http_server(3000, http_state).await;
    });

    // Spawn gRPC server (50051)
    let grpc_state = state.clone();
    tokio::spawn(async move {
        spawn_grpc_server("50051", grpc_state).await
            .expect("gRPC server error");
    });

    // Mantener servidor activo
    tokio::signal::ctrl_c().await.expect("Signal error");
    println!("Servidores detenidos");
}

```

---


## 6. Generar CÃ³digo Dart

```bash

# Instalar protoc en el sistema

# Windows: choco install protoc

# Linux: apt-get install protobuf-compiler

# Mac: brew install protobuf

# En backend_api/

protoc --dart_out=grpc:../mobile_app/lib/proto \
       --plugin=protoc-gen-grpc=`which grpc_dart_plugin` \
       proto/*.proto
       proto/*.proto

# Esto genera:

# - mobile_app/lib/proto/chat.pb.dart

# - mobile_app/lib/proto/chat.pbgrpc.dart

# - mobile_app/lib/proto/ledger.pb.dart

# - mobile_app/lib/proto/ledger.pbgrpc.dart

```

---


## 7. Actualizar `GrpcClient` en Flutter

```dart
// mobile_app/lib/services/grpc_client.dart

import 'package:grpc/grpc.dart';
import '../proto/chat.pbgrpc.dart';
import '../proto/ledger.pbgrpc.dart';

class GrpcClient extends ChangeNotifier {
  late ClientChannel _channel;
  late ChatServiceClient _chatService;
  late LedgerServiceClient _ledgerService;
  bool _isConnected = false;

  Future<bool> connect() async {
    try {
      _channel = ClientChannel(
        'localhost',
        port: 50051,
        options: const ChannelOptions(
          credentials: ChannelCredentials.insecure(),
        ),
      );

      _chatService = ChatServiceClient(_channel);
      _ledgerService = LedgerServiceClient(_channel);

      // Verificar conexiÃ³n
      await _chatService.listChannels(ListChannelsRequest());

      _isConnected = true;
      notifyListeners();
      return true;
    } catch (e) {
      debugPrint('Error: $e');
      return false;
    }
  }

  Future<bool> sendChatMessage(String text, String userId) async {
    try {
      final msg = ChatMessage(
        id: const Uuid().v4(),
        channelId: 'general',
        userId: userId,
        text: text,
        timestamp: DateTime.now().millisecondsSinceEpoch,
        userName: 'User',
      );

      final response = await _chatService.sendMessage(msg);
      return response.success;
    } catch (e) {
      debugPrint('Error: $e');
      return false;
    }
  }

  Stream<ChatMessage> getChatStream(String channelId) {
    final req = GetMessagesRequest(
      channelId: channelId,
      limit: 50,
    );
    return _chatService.getMessages(req);
  }
}

```

---


## 8. Testing gRPC Connection

```bash

# Desde mobile_app/

flutter run -d windows  # O tu dispositivo

# En otra terminal (si hace falta, iniciar mock server):

# cargo run --bin backend_api

```

---


## ðŸ“Š Timeline de ImplementaciÃ³n:

| Paso | Tarea | Tiempo | Status |

|------|-------|--------|--------|

| 1 | Crear proto files | 30 min | ðŸŸ¡ TODO |

| 2 | Generar cÃ³digo Rust | 15 min | ðŸŸ¡ TODO |

| 3 | Implementar handlers | 2 horas | ðŸŸ¡ TODO |

| 4 | Generar cÃ³digo Dart | 15 min | ðŸŸ¡ TODO |

| 5 | Actualizar GrpcClient | 1 hora | ðŸŸ¡ TODO |

| 6 | Testing E2E | 1 hora | ðŸŸ¡ TODO |

**Total:** ~5-6 horas de implementaciÃ³n
---


## ðŸŽ¯ VerificaciÃ³n de Ã‰xito:

- âœ… `cargo build` compila sin errores gRPC
- âœ… `flutter pub get` descarga dependencias gRPC
- âœ… `flutter run` conecta al puerto 50051
- âœ… Chat messages fluyen en tiempo real
- âœ… Ledger transactions se sellan correctamente
---
**Referencia:** [tonic gRPC Rust](https://github.com/hyperium/tonic)
**Referencia:** [gRPC Dart](https://pub.dev/packages/grpc)
